<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>CM2005 Object Oriented Programming Midterm Report</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="cm2005-object-oriented-programming-midterm-report">CM2005 Object Oriented Programming Midterm Report</h1>
<p>Name: Yue Wu</p>
<p>Student Number: 210312838</p>
<p>My goal for the midterm assignment is to enable users to view market data of the past 60 seconds in table, candlestick chart, and volume bar graph. The user can choose to view the data of a product and order type of their choice by type in the product name and order type in this format: <code>productName,orderType</code>, for example, <code>BTC/USDT,bid</code>. To achieve this goal, I performed the three following tasks. I also made some additional changes to the source code to make the program more clean and efficient.</p>
<h2 id="task-1-structure-the-program-compute-the-data-and-print-the-table">TASK 1: Structure the program, compute the data, and print the table</h2>
<p>For task 1, my goal is that given a product and order type, the program can compute its trading statistics of the past 60 seconds and print the results in a table. To do so, following the object oriented programming principle, I created a new class <code>Candlesticks</code> as well as made changes to the <code>OrderBook</code> class and <code>MerkelMain</code> class.</p>
<h3 id="11-change-the-program-start-time">1.1 Change the program start time</h3>
<p>Firstly, I examined the source code and noticed that the program begins with the earliest timestamp. The program then moves to the subsequent timestamp whenever the user inputs &quot;6&quot; and triggers the <code>gotoNextTimeframe</code> function.</p>
<p>The midterm instructions require students to visualize trading statistics. It would be strange to visualize statistics for &quot;the future&quot; since they haven't occurred yet. Therefore, I set my objective to display trading statistics from the past 60 seconds.</p>
<p>However, if the program started from the very first timestamp, there would be no trading history to analyze and display. To address this, I decided to have my program start from the 13th timestamp, which is 65 seconds after the earliest timestamp. (The gap between each timestamp is 5 seconds.)</p>
<p>In the <code>MerkelMain</code> class, I made the program start from the 13th timestamp by amending the <code>init</code> function and looping the <code>currentTime</code> member variable 12 times in the <code>getNextTime</code> function before everything else.</p>
<h3 id="12-expand-the-menu">1.2 Expand the menu</h3>
<p>In the source code, the menu has 6 options. The trading statistic visualization functionality will be the 7th option. I decided to call it <code>printCandlesticks</code>. In the <code>MerkelMain</code> class, I amended the <code>printMenu</code>, <code>getUserOption</code>, and <code>processUserOption</code> functions accordingly to include the new option.</p>
<p>Additionally, I refactored the <code>processUserOption</code> function. As an alternative to the if-else statements in the source code, I used the map function to map user input to the corresponding function. This reduces the number of lines of code and makes the code more concise and readable.</p>
<p>Also, the error handling was not robust enough in the source code. If user enters an integer that is not in the menu, for example &quot;999&quot;, the program will crash. The map function can solve this problem by the following code:</p>
<pre><code class="language-C++"><span class="hljs-keyword">if</span> (menu.<span class="hljs-built_in">find</span>(userOption) != menu.<span class="hljs-built_in">end</span>()) {
        <span class="hljs-comment">// process user option</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">printError</span>();
    }
</code></pre>
<h3 id="13-create-the-printcandlesticks-function">1.3 Create the <code>printCandlesticks</code> function</h3>
<p>For step 3, I implemented the <code>printCandlesticks</code> function in the <code>MerkelMain</code> class. The structure of the <code>printCandlesticks</code> function is similar to the <code>enterAsk</code> function in the source code.</p>
<ul>
<li>First, it prints the instructions.</li>
<li>Then, it takes user input and tokenizes it into tokens. Here, I also used regex functions to trim the leading and trailing whitespace from the tokens. This makes my program more user friendly.</li>
<li>Next, I validate whether the user input is valid by checking whether the number of tokens is 2, whether the first token is a valid product name, and whether the second token is a valid order type.</li>
<li>If the tokens are invalid, the program will print an error message.</li>
<li>Otherwise, the program will pass the tokens along with other necessary information to initialize a <code>Candlesticks</code> object and leave the rest of the work to the <code>Candlesticks</code> class.</li>
</ul>
<p>Encapsulating all the internal computation and visualization details in the <code>Candlesticks</code> class is a good practice of object oriented programming.</p>
<h3 id="14-code-the-candlesticks-class">1.4 Code the <code>Candlesticks</code> class</h3>
<p>For task 1, the main job of the <code>Candlesticks</code> class is to take necessary information from the outside world, calculate the trading statistics, and print the results in a table.</p>
<p>My considerations and decisions are as follows:</p>
<h4 id="141-member-variables">1.4.1 Member variables</h4>
<p>What outside information does the <code>Candlesticks</code> class need to perform the computation? The <code>Candlesticks</code> class needs the product name and order type to be sure. It also need to know the current time. Moreover, in order to analyze the orders of the past 60 seconds, it needs to have access to the order book. Thus, the <code>Candlesticks</code> class needs 4 constructor parameters in total: <code>product</code>, <code>orderType</code>, <code>timestamp</code>, and <code>orderBook</code>. They should be passed by reference to avoid unnecessary copying.</p>
<p>How should the <code>Candlesticks</code> class store the computed data? My decision is to use a vector of <code>Candlestick</code> objects. Each <code>Candlestick</code> object should store the open, close, high, and low prices of one timestamp. Since the <code>Candlestick</code> structure is simple, I decided to define it as a structure instead of a class:</p>
<pre><code class="language-C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Candlestick</span> {
    std::string time;
    <span class="hljs-type">double</span> open;
    <span class="hljs-type">double</span> high;
    <span class="hljs-type">double</span> low;
    <span class="hljs-type">double</span> close;
};
</code></pre>
<p>Hence, the <code>Candlesticks</code> class should have 5 member variables in total. They should all be private. Other than the candlesticks vector which we will edit later, the other 4 member variables should also be constants.</p>
<pre><code class="language-C++">std::vector&lt;Candlestick&gt; candlesticks;
<span class="hljs-type">const</span> std::string &amp;product;
<span class="hljs-type">const</span> std::string &amp;orderType;
<span class="hljs-type">const</span> std::string &amp;timestamp;
<span class="hljs-type">const</span> OrderBook &amp;orderBook;
</code></pre>
<h4 id="142-member-functions">1.4.2 Member functions</h4>
<p>Now we defined all the member variables, what member functions should the <code>Candlesticks</code> class have? Other than the constructor, it should have at least 2 public member functions: <code>compute</code> and <code>printTable</code>, so the outside world can call them to perform the computation and print the results respectively.</p>
<p>The <code>compute</code> function should loop 12 times back in time and eventually store 12 <code>Candlestick</code> objects (representing 12 timestamps, aka 60 seconds) in the candlesticks vector.</p>
<p>To loop back in time, I created a new helper function in the <code>OrderBook</code> class called <code>getPreviousTime</code>. It takes in a timestamp and returns the timestamp preceding it. The implementation is very similar to the <code>getNextTime</code> function in the source code. The only difference is that the <code>getPreviousTime</code> function loops through the orders vector in reverse order.</p>
<pre><code class="language-C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;order: std::ranges::<span class="hljs-built_in">reverse_view</span>(orders)) {
       <span class="hljs-comment">// ...</span>
    }
</code></pre>
<p>The implementation of the <code>compute</code> function is as follows:</p>
<pre><code>- convert orderType from string to OrderBookType

- store the current time in a local variable (because we don't want to mess the timestamp outside the `Candlesticks` class!)

- for each loop

    - get all the orders of the current timestamp

    - get the previous timestamp

    - get all the orders of the previous timestamp

    - calculate the open, high, low, and close prices based on the orders of the current timestamp and the previous timestamp

    - push the current time as well as all the calculated results (bundled as a `Candlestick` object) to the candlesticks vector

    - update the current time to the previous time
</code></pre>
<p>For the calculation, the source code already provided us with the <code>getHighPrice</code> and <code>getLowPrice</code> helper functions in the <code>OrderBook</code> class. I just need to code a <code>getAveragePrice</code> helper function following the same logic. The <code>getAveragePrice</code> function is stored in the <code>OrderBook</code> class next to its peers.</p>
<p>The <code>printTable</code> function should print the candlesticks vector in a table. The implementation is as follows:</p>
<pre><code>- print the table title

- print the header row

- for each candlestick in the candlesticks vector

    - set the color of the text based on whether the close price is higher than the open price

    - print the time, open, high, low, and close prices in a row

    - reset the color to default
</code></pre>
<p>The set color and reset color features will be used again later in task 2 and task 3, thus I separated them into private member functions called <code>setColor</code> and <code>clearColor</code>. Such separation of concerns follows the DRY principle and is a good practice in object-oriented programming.</p>
<p>Moreover, <code>compute</code> and <code>printTable</code> functions neither take any parameters nor return any values. Instead, they exhibits common environment coupling. This reduces interdependence and follows a good practice in object-oriented programming.</p>
<p>Another important detail to note is that, considering users' habits, I iterated through the candlesticks vector in reverse order. This ensures that the table displays the oldest timestamp at the top and the most recent timestamp at the bottom.</p>
<h3 id="15-call-the-candlesticks-class-and-its-member-functions">1.5 Call the <code>Candlesticks</code> class and its member functions</h3>
<p>Now that we have coded the <code>Candlesticks</code> class, we can instantiate a <code>Candlesticks</code> object and call its <code>compute</code> and <code>printTable</code> methods in the <code>printCandlesticks</code> function in the <code>MerkelMain</code> class. Now, when the user enters &quot;7&quot; in the menu, the program will print the trading statistics of the past 60 seconds in a table.</p>
<h2 id="task-2-visualize-the-data-in-a-candlestick-chart">TASK 2: visualize the data in a candlestick chart</h2>
<p>For task 2, my goal is to visualize the computed trading data in a candlestick chart. To do so, I created a new public method <code>printCandlestickChart</code> in the <code>Candlesticks</code> class and called it in the <code>printCandlesticks</code> function in the <code>MerkelMain</code> class.</p>
<p>Given that console prints text out row by row, we can divide a candlestick chart into 3 parts: the header on the top, the main body (with y-axis labels on the left and the candlesticks on the right), and the x-axis labels at the bottom.</p>
<h3 id="21-print-the-header-row">2.1 Print the header row</h3>
<p>Since the header row will be needed again for task 3, it's better to divide it into a separate private helper function called <code>drawHeaderRow</code> and call it within the <code>printCandlestickChart</code> function. To distinguish the header row between task 2 and task 3, I also included the y axis variable name as a parameter in the <code>drawHeaderRow</code> function.</p>
<h3 id="22-print-the-main-body">2.2 Print the main body</h3>
<p>Before we print the main body, we first need to decide: how many rows should the main body have? What should be the upper and lower bounds of the y-axis?</p>
<h3 id="23-print-the-x-axis-labels">2.3 Print the x-axis labels</h3>
<p>Similar to the header row, x-axis label printing functionality is divided into a separate private helper function called <code>drawXAxisLabels</code> and will be reused in task 3.</p>
<p>The x-axis variable is time. The x-axis labels should be the timestamps of the candlesticks. Since the timestamps are already stored in the candlesticks vector, we can simply iterate through the candlesticks vector and print them out. Because the timestamp strings are too long to look pretty, I also decided to refactor the <code>compute</code> class and only store a substring of the timestamp string in candlesticks vector. Instead of storing &quot;2020-01-01 00:00:00.00000&quot;, I only store &quot;00:00:00&quot;.</p>
<h2 id="task-3-visualize-some-trading-data-in-a-volume-bar-graph">TASK 3: visualize some trading data in a volume bar graph</h2>
<h2 id="other-changes-made-to-the-source-code">Other changes made to the source code</h2>
<h2 id="which-aspects-of-your-work-that-were-challenging-original-creative-exceptional">which aspects of your work that were challenging/ original/ creative/ exceptional.</h2>

        
        
    </body>
    </html>